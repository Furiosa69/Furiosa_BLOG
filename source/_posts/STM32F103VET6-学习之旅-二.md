---
title: 野火开发板 STM32F103VET6 学习之旅(二)
date: 2025-12-14 16:54:13
categories: STM32
tags: STM32F103VE
---

## STM32 须知

### 背景
STM32一经上市，就迅速占领了中低端MCU市场，受到了广大工程师的青睐。像市面上大部分小型四轴飞行器基本都能用STM32制作，入门级书籍可参考《四轴飞行器DIY—基于STM32微控制器》。

### 分类
STM32存在众多系列，从内核区分有Cortex-M0、M3、M4和M7，每个内核又主要分为主流、高性能和低功耗三类。初学者常用的类型有F1和F4。F1是基础型，基于Cortex-M3内核，主频为72MHz；F4是高性能型，基于Cortex-M4内核，主频180MHz。F4相较F1，除了内核及主频的不同，另外的优势在于支持LCD控制器、摄像头接口和SDRAM。
在选择STM32型号时，一般不需要接入大屏幕时选择基于Cortex-M3内核的F1系列，如果追求高性能需要大量数据运算，且需要外接RGB大屏幕时就选择Cortex-M4内核的F429系列。

1) 以野火F103指南者使用的STM32F103VET6来介绍STM32的命名方法：

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片1.png "" %}
</div>

2) 更详细的命名分类如下：

{% asset_img 图片2.png "" %}

### 开发手册
在开发时，有两个官方资料需要我们实时查询，一个是**参考手册（Reference manual）**，另一个是**数据手册（Data Sheet）**。两者大致区别在于，数据手册用于芯片选型及原理图设计，参考手册用于编程时查阅。两者具体区别如下：

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片3.png "" %}
</div>

参考手册可以从官方网站中下载，其中也包含了如何利用STM32进行产品开发的参考设计：https://www.stmcu.com.cn/Product/pro_detail/STM32F1/product

## 别问为什么，先点亮你的LED灯

### 新建工程
保持良好的项目管理习惯，我们先在D盘下新建一个工作目录STM32，用于存放之后所有实验的工程代码。
1) 新建项目，存放在LED文件夹下，项目名取LED_reg（reg代表我们将使用寄存器来实现LED项目）。
{% asset_img 图片4.png "" %}
2) 选择STM32F103VE型号，选择完后，跳出的在线添加库文件窗口可以直接关掉，因为这个工程用不到。

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片5.png "" %}
</div>

点击OK后，Keil5会自动生成两个文件夹，一个是Listings,另一个是Objects。

| 名称 | 作用 |
|:-------:|:------:|
| Listings | 存放编译时产生的c/汇编/链接文件的列表清单 |
| Objects | 存放编译产生的调试信息/hex文件/预览信息等 |

3) 添加文件，右键source group 1可以选择导入已有文件或者创建新文件。

{% asset_img 图片4.png "" %}

startup_stm32f10x_hd.s 启动文件，系统上电后第一个运行的程序，由汇编编写，C 编程用的比较少，可暂时不管，这个文件从固件库里面拷贝而来，由官方提供。一般在这个目录下：STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm\startup_stm32f10x_hd.s
stm32f10x.h 用户手动新建，用于存放寄存器映射的代码，暂时为空。
main.c 用户手动新建，用于存放main函数，暂时为空。

### 添加代码

``` C
#include "stm32f10x.h"
void SystemInit(void){}

int main (void)
{
	RCC_APB2ENR |= (1<<3);
	GPIOB_CRL &= ~(0x0F << (4*0));
	GPIOB_CRL |= (1<<4*0);
	GPIOB_ODR |= (0<<0);
	while(1);
}
```

``` h
#define PERIPH_BASE ((unsigned int)0x40000000)
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
#define GPIOB_BASE (APB2PERIPH_BASE + 0x0C00)
#define GPIOB_CRL *(unsigned int*)(GPIOB_BASE+0x00)
#define GPIOB_CRH *(unsigned int*)(GPIOB_BASE+0x04)
#define GPIOB_IDR *(unsigned int*)(GPIOB_BASE+0x08)
#define GPIOB_ODR *(unsigned int*)(GPIOB_BASE+0x0C)
#define GPIOB_BSRR *(unsigned int*)(GPIOB_BASE+0x10)
#define GPIOB_BRR *(unsigned int*)(GPIOB_BASE+0x14)
#define GPIOB_LCKR *(unsigned int*)(GPIOB_BASE+0x18)
#define RCC_BASE  (AHBPERIPH_BASE + 0x1000)
#define RCC_APB2ENR *(unsigned int*)(RCC_BASE+0x18)
```

### 烧录文件
参考[<<STM32F103VET6 学习之旅(一)>>]({% post_link STM32F103VET6-学习之旅-一.md %})第2.2及2.3的内容

## GPIO 须知
GPIO，即通用输入输出端口，通过将STM32的GPIO引脚与外部设备相连，从而实现与外部的通讯、控制以及数据采功能。STM32芯片的GPIO被分为很多组，每组有16个引脚，如我们使用用的STM32F103VET6型号的芯片就有GPIOA、GPIOB至GPIOE共5组GPIO。
最基本的输出功能是由STM32控制引脚输出高、低电平，从而实现开关控制，应用有利用GPIO口接入LED灯从而控制LED灯的亮灭。
最基本的输入功能是检测外部输入电平，应用有将GPIO与按键相连，通过高低电平可以区分按键是否被按下。

### 硬件结构剖析

{% asset_img 图片5.png "" %}

1) 保护二极管及上、下拉电阻：
	引脚的两个保护二级管可以防止引脚外部过高或过低的电压输入，尽管有保护，并不意味着STM32的引脚能直接外接大功率驱动器件，如直接驱动电机，强制驱动要么电机不转，要么导致芯片烧坏，必须要加大功率及隔离电路驱动。
	GPIO引脚线路经过两个保护二极管后，向上流向“输入模式”结构，向下流向“输出模式”结构。
2) P-MOS 管和 N-MOS 管：
	先看输出模式部分，线路经过一个由P-MOS和N-MOS管组成的单元电路。这个结构使GPIO具有了“推挽输出”和“开漏输出”两种模式。
	推挽输出模式，是根据这两个MOS管的工作方式来命名的。在该结构中输入高电平时，经过反向后，上方的P-MOS导通，下方的N-MOS关闭，对外输出高电平；而在该结构中输入低电平时，经过反向后，N-MOS管导通，P-MOS关闭，对外输出低电平。当引脚高低电平切换时，两个管子轮流导通，P管负责灌电流，N管负责拉电流，使其负载能力和开关速度都比普通的方式有很大的提高。推挽输出的低电平为0伏，高电平为3.3伏。

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片6.png "" %}
</div>

开漏输出模式，上方的P-MOS管完全不工作。如果我们控制输出为0，低电平，则P-MOS 管关闭，N-MOS管导通，使输出接地，若控制输出为1(它无法直接输出高电平)，则P-MOS 管和N-MOS管都关闭，所以引脚既不输出高电平，也不输出低电平，为高阻态。正常使用时必须外部接上拉电阻，它具有“线与”特性，也就是说，若有很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接的电源的电压。若其中一个引脚为低电平，那线路就相当于短路接地，使得整条线路都为低电平，0伏。

{% asset_img 图片7.png "" %}

推挽输出模式一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。在STM32 的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。除此之外，还用在电平不匹配的场合，如需要输出5伏的高电平，就可以在外部接一个上拉电阻，上拉电源为5伏，并且把GPIO设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出5伏的电平。

<div style="width:400px; margin: 0 auto;">
{% asset_img 图片8.png "" %}
</div>

3) 输出数据寄存器（Output Data Register）：
	前面提到的双MOS管结构电路的输入信号，是由GPIO的“输出数据寄存器GPIOx_ODR”提供的，因此我们通过修改输出数据寄存器的值就可以修改GPIO引脚的输出电平。而“置位/复位寄存器 GPIOx_BSRR”可以通过修改输出数据寄存器的值从而影响电路的输出。
4) 复用功能输出：
	“复用功能输出”中的“复用”是指STM32的其它片上外设对GPIO引脚进行控制，此时GPIO引脚用作该外设功能的一部分，算是第二用途。从其它外设引出来的“复用功能输出信号”与GPIO本身的数据据寄存器都连接到双MOS管结构的输入中，通过图中的梯形结构作为开关切换选择。例如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，由串口外设控制该引脚，发送数据。
5) 输入数据寄存器（Input Data Register）：
	看GPIO结构框图的上半部分，GPIO引脚经过内部的上、下拉电阻，可以配置成上/下拉输入，然后再连接到施密特触发器，信号经过触发器后，模拟信号转化为0、1的数字信号，然后存储在“输入数据寄存器GPIOx_IDR”中，通过读取该寄存器就可以了解GPIO引脚的电平状态。
6) 复用功能输入：
	与“复用功能输出”模式类似，在“复用功能输入”模式时，GPIO引脚的信号传输到STM32其它片上外设，由该外设读取引脚状态。 同样，如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯接收引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，使USART可以通过该通讯引脚的接收远端数据。
7) 模拟输入输出：
	当GPIO引脚用于ADC采集电压的输入通道时，用作“模拟输入”功能，此时信号是不经过施密特触发器的，因为经过施密特触发器后信号只有0、1两种状态，所以ADC外设要采集到原始的模拟信号，信号源输入必须在施密特触发器之前。类似地，当GPIO引脚用于DAC作为模拟电压输出通道时，此时作为“模拟输出”功能，DAC的模拟信号输出就不经过双MOS管结构，模拟信号直接输出到引脚。

### 工作模式
由GPIO的结构决定了GPIO可以配置成以下8钟工作模式：
``` C
typedef enum { 
GPIO_Mode_AIN = 0x0,			    // 模拟输入
GPIO_Mode_IN_FLOATING = 0x04, // 浮空输入 
GPIO_Mode_IPD = 0x28, 				// 下拉输入
GPIO_Mode_IPU = 0x48, 				// 上拉输入
GPIO_Mode_Out_OD = 0x14, 			// 开漏输出
GPIO_Mode_Out_PP = 0x10, 			// 推挽输出
GPIO_Mode_AF_OD = 0x1C, 			// 复用开漏输出
GPIO_Mode_AF_PP = 0x18		    // 复用推挽输出
} GPIOMode_TypeDef;    
```
固件库中的这8钟模式，可以大致归为以下三类：
1) 在输入模式时(模拟/浮空/上拉/下拉)，
	施密特触发器打开，输出被禁止，可通过输入数据寄存器GPIOx_IDR读取I/O状态。其中输入模式，可设置为上拉、下拉、浮空和模拟输入四种。上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，完全由外部的输入决定，一般接按键的时候用的是这个模式。模拟输入则用于ADC采集。
2) 在输出模式时(推挽/开漏)，
	推挽模式钟双MOS管以轮流方式工作，输出数据寄存器GPIOx_ODR可控制I/O 输出高低电平。开漏模式时，只有N-MOS管工作，输出数据寄存器可控制I/O输出高阻态或低电平。输出速度可配置，有2MHz/10MHz/50MHz的选项。此处的输出速度即I/O支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。
3) 在复用功能时(推挽/开漏)，
	输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器GPIOx_ODR无效；输入可用，通过输入数据寄存器可获取I/O实际状态，但一般直接用外设的寄存器来获取该数据信号。通过对GPIO寄存器写入不同的参数，就可以改变GPIO的工作模式，再强调一下，要了解具体寄存器时一定要查阅《STM32F10X-中文参考手册》中对应外设的寄存器说明。

### 端口配置寄存器
在GPIO外设中，控制端口高低控制寄存器CRH和CRL可以配置每个GPIO的工作模式和工作的速度，每4个位控制一个IO，CRH控制端口的高八位，CRL控制端口的低8位，具体的看CRH和CRL的寄存器描述。
1) 端口配置低寄存器（GPIOx_CRL）:

<div style="width:400px; margin: 0 auto;">
{% asset_img 图片9.png "" %}
</div>

2) 端口配置高寄存器（GPIOx_CRH）:

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片10.png "" %}
</div>

## 是时候问为什么了

### 为什么这么写startup_stm32f10x_hd.s
此文件是官方提供的启动文件，知晓其中的功能有助于我们理解机器的状态，不过这一节课暂时不表，或者感兴趣的同学自己去了解一下。

### 为什么这么写stm32f10x.h 
控制我们所需的寄存器，其实就是访问一个已经分配好地址的特殊空间，这个特殊的地址空间可以通过指针来操作。所以在编程之前我们需要先进行寄存器映射。此.h文件就是进行这一过程的行为。
GPIO外设的地址跟前面章节讲解的相同，不过此处把寄存器的地址值都直接强制转换成了指针，方便使用。代码的最后两段是RCC外设寄存器的地址定义，RCC外设是用来设置时钟的。

### 为什么这么写main.c 
在main.c中，我定义了一个空函数SystemInit(void)，看似起不到任何作用，但是如果注释掉这行代码，编译器会报错。通过仔细查看启动文件就知道，在Reset_Handler中调用了该函数以初始化STM32系统时钟，因为本实验用不到系统时钟，所以为了方便起见，我们在这里定义一个空函数以骗过编译器。
接下来就是正式的点灯之旅：
1) 首先我们把连接到LED灯的GPIO引脚PB0配置成输出模式，即配置GPIO的端口配置低寄存器CRL，MODE位用来配置输出的速度，CNF位用来配置各种输入输出模式。在这里我们把PB0配置为通用推挽输出，输出的速度为10M。

``` C
GPIOB_CRL &= ~(0x0F << (4*0));	// 清空控制 PB0 的端口位
GPIOB_CRL |= (1<<4*0);					// 配置 PB0 为通用推挽输出，速度为 10M
```

代码中使用了&=~、|=这种操作方法是为了避免影响到寄存器中的其它位，因为寄存器不能按位读写。

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片11.png "" %}
</div>

2) 在输出模式时，对端口位设置/清除寄存器BSRR寄存器、端口位清除寄存器BRR和ODR寄存器写入参数即可控制引脚的电平状态，其中操作BSRR和BRR最终影响的都是ODR寄存器，然后再通过ODR寄存器的输出来控制GPIO。为了一步到位，我们在这里直接操作ODR寄存器来控制GPIO的电平。

``` C
GPIOB_ODR &= ~(1<<0);	// PB0 输出低电平
```

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片12.png "" %}
</div>

3) 设置完GPIO的引脚，控制电平输出，以为现在总算可以点亮LED了吧，其实还差最后一步。由于STM32的外设很多，为了降低功耗，每个外设都对应着一个时钟，在芯片刚上电的时候这些时钟都是被关闭的，如果想要外设工作，必须把相应的时钟打开。
	STM32的所有外设的时钟由一个专门的外设来管理，叫RCC（resetandclockcontrol）。所有的GPIO都挂载到APB2总线上，具体的时钟由APB2外设时钟使能寄存器(RCC_APB2ENR) 来控制。

``` C
RCC_APB2ENR |= (1<<3);	// 开启 GPIOB 端口时钟
```

<div style="width:500px; margin: 0 auto;">
{% asset_img 图片13.png "" %}
</div>

**开启时钟，配置引脚模式，控制电平，经过这三步，我们总算可以控制一个LED了！**
